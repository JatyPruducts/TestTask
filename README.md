# Сервис распределения лидов (Mini-CRM)

Небольшой микросервис на **FastAPI** для автоматического распределения входящих заявок (лидов) между операторами.

Особенность данного проекта — гибкая настройка: можно задавать вес (компетенцию) оператора для каждого конкретного источника трафика. Также учитывается текущая загрузка оператора (лимиты).

## Технический стек

*   **Python 3.11**
*   **FastAPI** (Web framework)
*   **SQLAlchemy 2.0** (Async ORM)
*   **PostgreSQL** (через драйвер `asyncpg`)
*   **Pydantic** (валидация данных и настроек)
*   **Docker & Docker Compose**

## Конфигурация

Проект использует переменные окружения как для настройки приложения, так и для **инициализации базы данных** в Docker.

Перед запуском обязательно создайте файл **`.env`** в корне проекта.
Вы можете скопировать пример ниже:

```ini
# Настройки PostgreSQL
DB_USER=postgres
DB_PASSWORD=postgres
DB_HOST=db
DB_PORT=5432
DB_NAME=crm_db

# Настройки приложения
APP_HOST=0.0.0.0
APP_PORT=8000
DEBUG=True
```

### Примечание ###
`docker-compose.yml` настроен так, что он берет значения `DB_USER`, `DB_PASSWORD` и `DB_NAME` прямо из этого файла. Это гарантирует, что и база данных, и приложение используют одни и те же учетные данные.

## Способ запуска

Всё упаковано в Docker, поэтому локально ставить Python или Postgres не нужно.

1.  **Клонировать репозиторий:**
    ```bash
    git clone https://github.com/JatyPruducts/TestTask.git
    cd TestTask
    ```

2.  **Запустить одной командой:**
    ```bash
    docker-compose up --build
    ```
    или для запуска в фоновом режиме
    ```bash
    docker-compose up -d --build
    ``` 

3.  **Открыть документацию:**
    После запуска (обычно занимает 5-10 секунд на инициализацию БД) перейдите в браузере:
    *   Swagger UI: [http://localhost:8000/docs](http://localhost:8000/docs)

> **Важно:** При первом запуске сервис сам создаст необходимые таблицы в базе данных. Миграции (Alembic) в рамках тестового задания я не подключал, чтобы не усложнять сборку, но использую `lifespan` в FastAPI для инициализации схем.

## Модели данных и архитектура

Я выбрал схему с промежуточной таблицей для весов, чтобы обеспечить гибкость `Many-to-Many`.

1.  **Operator**: Хранит имя, статус (`is_active`) и глобальный лимит нагрузки (`max_load`).
2.  **Source**: Источник, откуда приходят заявки (например, "Telegram", "Сайт").
3.  **SourceOperatorConfig**: Ключевая сущность. Связывает Оператора и Источник, храня поле `weight`.
    *   *Пример:* Оператор Иван на источнике "Сайт" имеет вес 10, а на источнике "Телефон" — вес 50.
4.  **Lead**: Конечный клиент. Идентифицируется по `client_id` (строка, например, номер телефона). Если клиент пишет повторно — мы находим старую запись.
5.  **Inquiry (Обращение)**: Факт заявки. Имеет связь с Лидом, Источником и назначенным Оператором.
    *   Поле `is_active` определяет, занят ли слот у оператора.

## Алгоритм распределения

Логика находится в `app/services.py`. При поступлении новой заявки (`POST /inquiries`):

1.  **Поиск Лида**: Поиск в БД по `client_id`. Если нет — создаем.
2.  **Отбор кандидатов**:
    *   Берутся все операторы, привязанные к данному источнику.
    *   Отфильтровываются те, у кого `is_active = False`.
3.  **Проверка лимитов**:
    *   Выполняется `COUNT(*)` активных обращений по каждому кандидату.
    *   Исключаются те, у кого `текущая_нагрузка >= max_load`.
4.  **Вероятностный выбор**:
    *   Оставшиеся кандидаты отдаются функции `random.choices()`, передавая их веса.
    *   Это гарантирует, что оператор с весом 20 будет получать лидов в 2 раза чаще, чем оператор с весом 10 (на длинной дистанции).
5.  **Результат**:
    *   Если оператор найден — сохраняем `Inquiry` с его ID.
    *   **Edge case:** Если подходящих операторов нет (все заняты или неактивны), заявка создается с `operator_id = NULL`. Я решил не возвращать 4xx ошибку, чтобы бизнес не терял лида, даже если обработать его некому прямо сейчас.

## Ручное тестирование (пример)

Чтобы проверить работу весов и лимитов через Swagger:

1.  Создайте двух операторов: **Junior** (лимит 2, вес настроим маленький) и **Senior** (лимит 10, вес большой).
2.  Создайте источник.
3.  Через `POST /sources/{id}/config` задайте веса (например, 10 и 90).
4.  Начните отправлять запросы на `POST /inquiries` с разными `client_id`.
    *   Вы увидите, что **Senior** получает большинство заявок.
    *   Как только у **Junior** наберется 2 активных заявки, он перестанет получать новые, пока старые не будут закрыты (статус активности пока меняется только вручную в БД, для простоты).

## Структура проекта

```text
├── app/
│   ├── main.py          # Точка входа, lifespan
│   ├── models.py        # SQLAlchemy модели
│   ├── schemas.py       # Pydantic схемы (DTO)
│   ├── services.py      # Бизнес-логика распределения
│   ├── routers.py       # API контроллеры
│   ├── database.py      # Настройки сессии БД
│   └── config.py        # Чтение .env
├── docker-compose.yml
├── Dockerfile
├── .env                 # Конфигурация (не комитится в git)
└── requirements.txt
```